model_lm_lasso <- cv.glmnet(x = as.matrix(dados_treino[, -7]), y = dados_treino$mean...Energy.consumption..kWh.100.km.,
alpha = 1) # Usando alpha = 1 para Lasso
# Encontrando o melhor valor de lambda (parâmetro de regularização) com validação cruzada
best_lambda <- model_lm_lasso$lambda.min
# Criando o modelo final com o melhor lambda
final_model_lm_lasso <- glmnet(x = as.matrix(dados_treino[, -7]), y = dados_treino$mean...Energy.consumption..kWh.100.km.,
alpha = 1, lambda = best_lambda)
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]), best_lambda)
previsoes <- predict(final_model_lm_lasso, s = best_lambda, newx = as.matrix(dados_teste[, -7]))
previsoes
## Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
print('iae')
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste$mean...Energy.consumption..kWh.100.km.
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
## Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
print('iae')
model_type
dados_teste
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste$mean...Energy.consumption..kWh.100.km.
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
previsoes <- predict(final_model_lm_lasso, s = best_lambda, newx = as.matrix(dados_teste))
previsoes <- predict(final_model_lm_lasso, s = best_lambda, newx = as.matrix(dados_teste[, -7]))
previsoes
## Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste$mean...Energy.consumption..kWh.100.km.
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[["mean...Energy.consumption..kWh.100.km."]]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
print(avaliacao_lm_lasso)
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
str(dados_teste)
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[["mean...Energy.consumption..kWh.100.km."]]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[-7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
str(dados_teste)
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste)
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[["mean...Energy.consumption..kWh.100.km."]]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = as.matrix(dados_teste[, -7]))
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
## Regressão Linear Lasso (lm_lasso)
model_lm_lasso <- cv.glmnet(x = as.matrix(dados_treino[, -7]), y = dados_treino$mean...Energy.consumption..kWh.100.km.,
alpha = 1) # Usando alpha = 1 para Lasso
# Encontrando o melhor valor de lambda (parâmetro de regularização) com validação cruzada
best_lambda <- model_lm_lasso$lambda.min
# Criando o modelo final com o melhor lambda
final_model_lm_lasso <- glmnet(x = as.matrix(dados_treino[, -7]), y = dados_treino$mean...Energy.consumption..kWh.100.km.,
alpha = 1, lambda = best_lambda)
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = dados_teste)
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
# Fazendo previsões no conjunto de teste
avaliacao_lm_lasso <- avaliar_modelo(final_model_lm_lasso, "lm_lasso", as.matrix(dados_teste[, -7]))
print(avaliacao_lm_lasso)
## Carregando dados
dados <- data.frame(read_xlsx("dataset/FEV-data-Excel.xlsx"))
dados <- dados[complete.cases(dados), ]
## Engenharia de Atributos
# Convertendo a variável variáveis chr para fator
dados <- dados %>%
mutate_if(is.character, factor) %>%
mutate(across(c(Number.of.seats, Number.of.doors), as.factor))
# Normalização dos Dados (variáveis numéricas) (Exemplo 1 coluna ao final)
numeric_columns <- sapply(dados, is.numeric)
dados_nor <- dados %>%
mutate(across(where(is.numeric), ~ scale(., center = min(.), scale = max(.) - min(.))))
rm(numeric_columns)
# Reverter Normalização
# dados_revertidos <- dados_nor %>%
#   mutate(across(where(is.numeric), ~ (. * (max(dados[, cur_column()]) - min(dados[, cur_column()])) + min(dados[, cur_column()]))))
## Selecionando variaveis
dados_nor <- dados_nor %>%
select(Make, Wheelbase..cm., Permissable.gross.weight..kg.,
Minimal.price..gross...PLN., Length..cm., Width..cm.,
mean...Energy.consumption..kWh.100.km.)
str(dados_nor)
#### Criando Modelos
## Dividindo os dados em treino e teste
set.seed(150)
indices <- createDataPartition(dados_nor$mean...Energy.consumption..kWh.100.km., p = 0.80, list = FALSE)
dados_treino <- dados_nor[indices, ]
dados_teste <- dados_nor[-indices, ]
rm(indices)
## Preparação dos dados para kNN (conversão para matriz)
dados_treino_knn <- data.matrix(dados_treino[,-7])
dados_teste_knn <- data.matrix(dados_teste[,-7])
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = dados_teste[, -7])
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
## Salvando avaliação dos modelos em uma List()
modelos_params <- list()
## RandomForest
model_rf <- randomForest(mean...Energy.consumption..kWh.100.km. ~
Make + Wheelbase..cm. + Permissable.gross.weight..kg. +
Minimal.price..gross...PLN. + Length..cm. + Width..cm.,
data = dados_treino,
ntree = 100, nodesize = 10, importance = TRUE, set.seed(100))
avaliacao_rf <- avaliar_modelo(model_rf, "rm", dados_teste)
print(avaliacao_rf)
## SVM
model_svm <- svm(mean...Energy.consumption..kWh.100.km. ~ ., data = dados_treino)
avaliacao_svm <- avaliar_modelo(model_svm, "svm", dados_treino)
print(avaliacao_svm)
## kNN
model_knn <- knn(train = dados_treino_knn, test = dados_teste_knn, cl = dados_treino$mean...Energy.consumption..kWh.100.km., k = 1)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino_knn)
print(avaliacao_knn)
# - Utilizando as configurações da versão 3 (sem a criação das novas variáveis)
## Carregando dados
dados <- data.frame(read_xlsx("dataset/FEV-data-Excel.xlsx"))
dados <- dados[complete.cases(dados), ]
## Engenharia de Atributos
# Convertendo a variável variáveis chr para fator
dados <- dados %>%
mutate_if(is.character, factor) %>%
mutate(across(c(Number.of.seats, Number.of.doors), as.factor))
# Normalização dos Dados (variáveis numéricas) (Exemplo 1 coluna ao final)
numeric_columns <- sapply(dados, is.numeric)
dados_nor <- dados %>%
mutate(across(where(is.numeric), ~ scale(., center = min(.), scale = max(.) - min(.))))
rm(numeric_columns)
# Reverter Normalização
# dados_revertidos <- dados_nor %>%
#   mutate(across(where(is.numeric), ~ (. * (max(dados[, cur_column()]) - min(dados[, cur_column()])) + min(dados[, cur_column()]))))
## Selecionando variaveis
dados_nor <- dados_nor %>%
select(Make, Wheelbase..cm., Permissable.gross.weight..kg.,
Minimal.price..gross...PLN., Length..cm., Width..cm.,
mean...Energy.consumption..kWh.100.km.)
str(dados_nor)
#### Criando Modelos
## Dividindo os dados em treino e teste
set.seed(150)
indices <- createDataPartition(dados_nor$mean...Energy.consumption..kWh.100.km., p = 0.80, list = FALSE)
dados_treino <- dados_nor[indices, ]
dados_teste <- dados_nor[-indices, ]
rm(indices)
## Preparação dos dados para kNN (conversão para matriz)
dados_treino_knn <- data.matrix(dados_treino[,-7])
dados_teste_knn <- data.matrix(dados_teste[,-7])
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = dados_teste[, -7])
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
## Salvando avaliação dos modelos em uma List()
modelos_params <- list()
## kNN
model_knn <- knn(train = dados_treino_knn, test = dados_teste_knn, cl = dados_treino$mean...Energy.consumption..kWh.100.km., k = 1)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino_knn)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino)
## Carregando dados
dados <- data.frame(read_xlsx("dataset/FEV-data-Excel.xlsx"))
dados <- dados[complete.cases(dados), ]
## Engenharia de Atributos
# Convertendo a variável variáveis chr para fator
dados <- dados %>%
mutate_if(is.character, factor) %>%
mutate(across(c(Number.of.seats, Number.of.doors), as.factor))
# Normalização dos Dados (variáveis numéricas) (Exemplo 1 coluna ao final)
numeric_columns <- sapply(dados, is.numeric)
dados_nor <- dados %>%
mutate(across(where(is.numeric), ~ scale(., center = min(.), scale = max(.) - min(.))))
rm(numeric_columns)
# Reverter Normalização
# dados_revertidos <- dados_nor %>%
#   mutate(across(where(is.numeric), ~ (. * (max(dados[, cur_column()]) - min(dados[, cur_column()])) + min(dados[, cur_column()]))))
## Selecionando variaveis
dados_nor <- dados_nor %>%
select(Make, Wheelbase..cm., Permissable.gross.weight..kg.,
Minimal.price..gross...PLN., Length..cm., Width..cm.,
mean...Energy.consumption..kWh.100.km.)
str(dados_nor)
#### Criando Modelos
## Dividindo os dados em treino e teste
set.seed(150)
indices <- createDataPartition(dados_nor$mean...Energy.consumption..kWh.100.km., p = 0.80, list = FALSE)
dados_treino <- dados_nor[indices, ]
dados_teste <- dados_nor[-indices, ]
rm(indices)
## Preparação dos dados para kNN (conversão para matriz)
dados_treino_knn <- data.matrix(dados_treino[,-7])
dados_teste_knn <- data.matrix(dados_teste[,-7])
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = dados_teste[, -7])
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
## Salvando avaliação dos modelos em uma List()
modelos_params <- list()
## RandomForest
model_rf <- randomForest(mean...Energy.consumption..kWh.100.km. ~
Make + Wheelbase..cm. + Permissable.gross.weight..kg. +
Minimal.price..gross...PLN. + Length..cm. + Width..cm.,
data = dados_treino,
ntree = 100, nodesize = 10, importance = TRUE, set.seed(100))
avaliacao_rf <- avaliar_modelo(model_rf, "rm", dados_teste)
print(avaliacao_rf)
## SVM
model_svm <- svm(mean...Energy.consumption..kWh.100.km. ~ ., data = dados_treino)
avaliacao_svm <- avaliar_modelo(model_svm, "svm", dados_teste)
print(avaliacao_svm)
## kNN
model_knn <- knn(train = dados_treino_knn, test = dados_teste_knn, cl = dados_treino$mean...Energy.consumption..kWh.100.km., k = 1)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino)
## Carregando dados
dados <- data.frame(read_xlsx("dataset/FEV-data-Excel.xlsx"))
dados <- dados[complete.cases(dados), ]
## Engenharia de Atributos
# Convertendo a variável variáveis chr para fator
dados <- dados %>%
mutate_if(is.character, factor) %>%
mutate(across(c(Number.of.seats, Number.of.doors), as.factor))
# Normalização dos Dados (variáveis numéricas) (Exemplo 1 coluna ao final)
numeric_columns <- sapply(dados, is.numeric)
dados_nor <- dados %>%
mutate(across(where(is.numeric), ~ scale(., center = min(.), scale = max(.) - min(.))))
rm(numeric_columns)
# Reverter Normalização
# dados_revertidos <- dados_nor %>%
#   mutate(across(where(is.numeric), ~ (. * (max(dados[, cur_column()]) - min(dados[, cur_column()])) + min(dados[, cur_column()]))))
## Selecionando variaveis
dados_nor <- dados_nor %>%
select(Make, Wheelbase..cm., Permissable.gross.weight..kg.,
Minimal.price..gross...PLN., Length..cm., Width..cm.,
mean...Energy.consumption..kWh.100.km.)
str(dados_nor)
#### Criando Modelos
## Dividindo os dados em treino e teste
set.seed(150)
indices <- createDataPartition(dados_nor$mean...Energy.consumption..kWh.100.km., p = 0.80, list = FALSE)
dados_treino <- dados_nor[indices, ]
dados_teste <- dados_nor[-indices, ]
rm(indices)
## Preparação dos dados para kNN (conversão para matriz)
dados_treino_knn <- data.matrix(dados_treino[,-7])
dados_teste_knn <- data.matrix(dados_teste[,-7])
# Função para avaliar os modelos
avaliar_modelo <- function(model, model_type, dados_teste) {
if (model_type %in% c("lm", "svm", "gbm", "tree", "rm")) {
previsoes <- predict(model, newdata = dados_teste[, -7])
} else if (model_type == "knn") {
previsoes <- model
if (is.factor(previsoes)) {
previsoes <- as.numeric(levels(previsoes))[previsoes]
}
} else if (model_type == "lm_lasso") {
previsoes <- predict(final_model_lm_lasso, s = model_lm_lasso$lambda.min, newx = dados_teste[, -7])
} else {
previsoes <- predict(model, newdata = dados_teste[, -7])
}
# Calculando as métricas de avaliação
verdadeiro <- dados_teste[, "mean...Energy.consumption..kWh.100.km."]
rmse <- sqrt(mean((previsoes - verdadeiro)^2))
mae <- mean(abs(previsoes - verdadeiro))
r2 <- cor(previsoes, verdadeiro)^2
return(c(RMSE = rmse, MAE = mae, `R-squared` = r2))
}
## Salvando avaliação dos modelos em uma List()
modelos_params <- list()
## RandomForest
model_rf <- randomForest(mean...Energy.consumption..kWh.100.km. ~
Make + Wheelbase..cm. + Permissable.gross.weight..kg. +
Minimal.price..gross...PLN. + Length..cm. + Width..cm.,
data = dados_treino,
ntree = 100, nodesize = 10, importance = TRUE, set.seed(100))
avaliacao_rf <- avaliar_modelo(model_rf, "rm", dados_teste)
print(avaliacao_rf)
## SVM
model_svm <- svm(mean...Energy.consumption..kWh.100.km. ~ ., data = dados_treino)
avaliacao_svm <- avaliar_modelo(model_svm, "svm", dados_teste)
print(avaliacao_svm)
## kNN
model_knn <- knn(train = dados_treino_knn, test = dados_teste_knn, cl = dados_treino$mean...Energy.consumption..kWh.100.km., k = 1)
avaliacao_knn <- avaliar_modelo(model_knn, "knn", dados_treino)
print(avaliacao_knn)
## SVM
model_svm <- svm(mean...Energy.consumption..kWh.100.km. ~ ., data = dados_treino)
avaliacao_svm <- avaliar_modelo(model_svm, "svm", dados_teste)
print(avaliacao_svm)
